import io
from pytube import YouTube
from lxml import etree
from os import getenv
try:    
    from secret_key import TEST_MODE
except:
    TEST_MODE = int(getenv('TEST_MODE'))

if TEST_MODE==1:
    try:    
        from secret_key import API_KEY_EDENAI_SANDBOX
    except:
        API_KEY_EDENAI_SANDBOX = getenv('API_KEY_EDENAI_SANDBOX')
    # Configuration for EdenAI
    headers = {"Authorization": API_KEY_EDENAI_SANDBOX}
else:
    try:    
        from secret_key import API_KEY_EDENAI
    except:
        API_KEY_EDENAI = getenv('API_KEY_EDENAI')
    # Configuration for EdenAI
    headers = {"Authorization": API_KEY_EDENAI}

import json
import requests
from PIL import Image
from io import BytesIO
import pytube.exceptions as exceptions
from pytube.innertube import InnerTube
import warnings
warnings.filterwarnings('ignore')

# Create a subclass of YouTube
class MyYouTube(YouTube):
    # Rewrite the function in pytube library for the possibility to iterate clients like "WEB", "ANDROID"...
    def bypass_age_gate(self, client):
        """Attempt to update the vid_info by bypassing the age gate."""
        innertube = InnerTube(
            client=client,
            use_oauth=self.use_oauth,
            allow_cache=self.allow_oauth_cache
        )
        innertube_response = innertube.player(self.video_id)

        playability_status = innertube_response['playabilityStatus'].get('status', None)

        # If we still can't access the video, raise an exception
        # (tier 3 age restriction)
        if playability_status == 'UNPLAYABLE':
            raise exceptions.AgeRestrictedError(self.video_id)

        self._vid_info = innertube_response


# To imitate the open('file_path.mp4','rb')
class NamedBufferedReader:
    def __init__(self, raw, name):
        self.buffered_reader = io.BufferedReader(raw)
        self.name = name

    def read(self, *args, **kwargs):
        return self.buffered_reader.read(*args, **kwargs)

    def readline(self, *args, **kwargs):
        return self.buffered_reader.readline(*args, **kwargs)

    def readlines(self, *args, **kwargs):
        return self.buffered_reader.readlines(*args, **kwargs)

    def __getattr__(self, attr):
        return getattr(self.buffered_reader, attr)


def speech_to_text(audio_bytes, provider='openai'):
    # EdenAI version (openai provider)
    url = "https://api.edenai.run/v2/audio/speech_to_text_async"
    data = {
        "providers": provider,
        "language": "en-US",
    }
    files = {'file': audio_bytes}
    response = requests.post(url, data=data, files=files, headers=headers)
    provider_result = json.loads(response.text)['results'][provider]
    try:
        result = provider_result['text']
        return result
    except:
        raise ValueError(provider_result)


# SubFunctions
def get_post_txt(yt): # Get subtitles or generate from video's audio
    try:
        all_captions = yt.captions # WARNING: add check of auto-generated by yt.captions['a.en']

        if 'en' in all_captions:
            eng_captions = all_captions['en']
        # elif 'a.en' in all_captions:
        #     eng_captions = all_captions['a.en']
        else:
            raise ValueError("Video doesn't have subtitles, need to create")
        
        xml_captions = eng_captions.xml_captions

        # Parse the XML
        root = etree.fromstring(xml_captions.encode('utf-8'))
        text_blocks = []
        for child in root.findall('.//body/p'):
            text_block = ''.join(child.itertext()).strip().replace('\n', ' ')
            cleaned_text_block = text_block.replace('[Music]','').strip()
            if cleaned_text_block!='':
                text_blocks.append(cleaned_text_block)
            
        transcription = ', '.join(text_blocks) # WARNING: maybe change to dots or smth
    except:
        # Function to get audio bytes from a YouTube video
        def get_audio_bytes(yt):
        
            # Filter audio streams and get the first one (usually 'mp4')
            audio_stream = yt.streams.filter(only_audio=True).first()
            
            # Download the audio stream to a buffer
            audio_buffer = io.BytesIO()
            audio_stream.stream_to_buffer(audio_buffer)
            
            # Get the bytes from the buffer
            audio_bytes = audio_buffer.getvalue()
            
            return audio_bytes
        
        # Imitating open('file_path.mp4','rb')
        def get_buffered_reader(audio_bytes):
            # Step 2: Create an in-memory binary stream from the audio bytes
            bytes_io = io.BytesIO(audio_bytes)

            # Step 3: Wrap the BytesIO stream with NamedBufferedReader
            named_buffered_reader = NamedBufferedReader(bytes_io, 'yt_audio/Me at the zoo.mp4')
            return named_buffered_reader
        
        audio_bytes = get_audio_bytes(yt)
        named_buffered_reader = get_buffered_reader(audio_bytes)
        transcription = speech_to_text(named_buffered_reader)


    # Summarize trascription
    def get_summary(transcription:str, words_amount:int=150, light_model:str='gpt-3.5-turbo', heavy_model:str='gpt-4o'):
        url = "https://api.edenai.run/v2/text/chat"

        transcription_length = len(transcription.split())
        if transcription_length<2500:
            model = light_model
        else:
            model = heavy_model

        payload = {
            "providers": "openai",
            "text": transcription,
            "chatbot_global_action": f"Convey the essense with around {words_amount} words. Don't speak in third person. Don't say thx for like, watching, or write a comment under the video.",
            "previous_history": [],
            "temperature": 0.0,
            "max_tokens": 150,
            "model": model
        }
        response = requests.post(url, json=payload, headers=headers)

        result = json.loads(response.text)
        try:
            summary = result['openai']['generated_text']
        except:
            raise ValueError(f'Response from EdenAI is not good: {result}')
        return summary
    
    summary = get_summary(transcription)
    return summary


def get_post_img(yt, thumbnail=True):
    # Get the video's thumbnail
    if thumbnail:
        thumbnail_url = yt.thumbnail_url

        # Send a GET request to the URL
        response = requests.get(thumbnail_url)

        # Save image
        image = Image.open(BytesIO(response.content))

        # Define the cropping box
        # (left, upper, right, lower) - crop 10% from each side
        width, height = image.size
        left = 0
        right = width
        upper = height * 0.13
        lower = height * 0.87
        croped_img = image.crop((left, upper, right, lower))

        # Convert img to byte array
        img_byte_arr = io.BytesIO()
        croped_img.save(img_byte_arr, format='JPEG')
        img_byte_arr = img_byte_arr.getvalue()

        # return img_path
        return img_byte_arr
        
    # Generate the video (Then maybe add option to get images from internet)
    else: 
        pass


# MainFunction
def VideoToPost(link, lang='en', reference='no', img=False): # WARNING: include the language,reference logic a bit later
    yt = MyYouTube(link)
    clients = ['WEB', 'ANDROID', 'IOS', 'WEB_EMBED', 'ANDROID_EMBED', 'IOS_EMBED', 'WEB_MUSIC', 'ANDROID_MUSIC', 'IOS_MUSIC', 'WEB_CREATOR', 'ANDROID_CREATOR', 'IOS_CREATOR', 'MWEB', 'TV_EMBED']
    for client in clients:
        try:
            # I modified the function bypass_age_gate() in pytube/__main__
            yt.bypass_age_gate(client=client)
            break
        except:
            continue
    post_name = yt.title + ' (' + yt.author + ')'
    post_txt = get_post_txt(yt)
    if img:
        post_img = get_post_img(yt, post_name)
        overall_post = {'post_txt':post_txt,'post_img':post_img}
    else:
        overall_post = {'post_txt':post_txt}
    return post_name, overall_post

#link = 'https://youtu.be/jNQXAC9IVRw?si=gjx36t0J7pZtvDyd' # with subtitles
#link = 'https://youtu.be/GC80Dk7eg_A?si=n9pIQh0f_A-zVbA_' # with generative subtitles

#VideoToPost(link)